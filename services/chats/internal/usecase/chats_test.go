package usecase_test

import (
	"context"
	"errors"
	"testing"

	"github.com/AlexeyTarasov77/messanger.chats/internal/dto"
	"github.com/AlexeyTarasov77/messanger.chats/internal/entity"
	"github.com/AlexeyTarasov77/messanger.chats/internal/gateways/storage"
	"github.com/AlexeyTarasov77/messanger.chats/internal/usecase/chats"
	"github.com/brianvoe/gofakeit"
	"github.com/stretchr/testify/assert"
)

var fakeErr = errors.New("fake error")

type testCase struct {
	name     string
	mock     func()
	expected any
	err      error
}

func TestListChats(t *testing.T) {
	ctx := context.Background()
	suite := NewUseCaseTestSuite(t)
	expectedChats := []entity.Chat{newTestChat(), newTestChat()}
	testCases := []testCase{
		{
			name: "repo error",
			mock: func() {
				suite.mockChatsRepo.EXPECT().GetAll(ctx).Return(nil, fakeErr)
			},
			expected: []entity.Chat(nil),
			err:      fakeErr,
		},
		{
			name: "success",
			mock: func() {
				suite.mockChatsRepo.EXPECT().GetAll(ctx).Return(expectedChats, nil)
			},
			expected: expectedChats,
		},
	}

	for _, tc := range testCases {
		tc.mock()
		chats, err := suite.chatsUseCase.ListChats(ctx)
		assert.ErrorIs(t, tc.err, err)
		assert.Equal(t, tc.expected.([]entity.Chat), chats)
	}
}

func TestCreatePersonalChat(t *testing.T) {
	ctx := context.Background()
	suite := NewUseCaseTestSuite(t)
	payload := &dto.CreatePersonalChat{CurrentUserId: gofakeit.Number(1, 999999), WithUserId: gofakeit.Number(1, 999999)}
	chatToInsert := &entity.PersonalChat{FromUserId: payload.CurrentUserId, ToUserId: payload.WithUserId}
	expectedChat := &entity.PersonalChat{Chat: newTestChat()}
	testCases := []testCase{
		{
			name: "save error (unhandled)",
			mock: func() {
				checkExistsCall := suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, []int{payload.WithUserId}).Return(true, nil)
				suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(nil, fakeErr).After(checkExistsCall)
			},
			expected: (*entity.PersonalChat)(nil),
			err:      fakeErr,
		},
		{
			name: "save error - already exists",
			mock: func() {
				checkExistsCall := suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, []int{payload.WithUserId}).Return(true, nil)
				suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(nil, storage.ErrAlreadyExists).After(checkExistsCall)
			},
			expected: (*entity.PersonalChat)(nil),
			err:      chats.ErrChatAlreadyExists,
		},
		{
			name: "user not found",
			mock: func() {
				suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, []int{payload.WithUserId}).Return(false, nil)
			},
			expected: (*entity.PersonalChat)(nil),
			err:      chats.ErrUserNotFound,
		},
		{
			name: "usersRepo.checkExistsAll error (unhandled)",
			mock: func() {
				suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, []int{payload.WithUserId}).Return(false, fakeErr)
			},
			expected: (*entity.PersonalChat)(nil),
			err:      fakeErr,
		},
		{
			name: "success",
			mock: func() {
				checkExistsCall := suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, []int{payload.WithUserId}).Return(true, nil)
				suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(expectedChat, nil).After(checkExistsCall)
			},
			expected: expectedChat,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tc.mock()
			chat, err := suite.chatsUseCase.CreatePersonalChat(ctx, payload)
			assert.ErrorIs(t, err, tc.err)
			assert.Equal(t, tc.expected, chat)
		})
	}
}

func createGroupChatPayload() *dto.CreateGroupChat {
	return &dto.CreateGroupChat{
		CurrentUserId: gofakeit.Number(1, 999999),
		Name:          gofakeit.Name(),
		Slug:          gofakeit.Name(),
		ImageURL:      gofakeit.URL(),
		Description:   gofakeit.Sentence(5),
		MembersIds:    []int{gofakeit.Number(1, 999999), gofakeit.Number(1, 999999)},
		IsPublic:      gofakeit.Bool(),
	}

}

func TestCreateGroupChat(t *testing.T) {
	suite := NewUseCaseTestSuite(t)
	t.Run("success with members", func(t *testing.T) {
		ctx := context.Background()
		payload := createGroupChatPayload()
		chatToInsert := payload.MapToEntity()
		expectedChat := &entity.GroupChat{Chat: newTestChat()}
		checkExistsCall := suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, payload.MembersIds).Return(true, nil)
		suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(expectedChat, nil).After(checkExistsCall)

		chat, err := suite.chatsUseCase.CreateGroupChat(ctx, payload)
		assert.NoError(t, err)
		assert.Equal(t, expectedChat, chat)
	})
	t.Run("success without members", func(t *testing.T) {
		ctx := context.Background()
		payload := createGroupChatPayload()
		payload.MembersIds = nil
		chatToInsert := payload.MapToEntity()
		expectedChat := &entity.GroupChat{Chat: newTestChat()}
		suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(expectedChat, nil)

		chat, err := suite.chatsUseCase.CreateGroupChat(ctx, payload)
		assert.NoError(t, err)
		assert.Equal(t, expectedChat, chat)
	})
	t.Run("success with autogenerated slug", func(t *testing.T) {
		ctx := context.Background()
		payload := createGroupChatPayload()
		payload.MembersIds = nil
		payload.Slug = ""
		generatedSlug := gofakeit.UUID()
		suite.mockSlugGenerator.EXPECT().GenerateRandomSlug().Return(generatedSlug, nil)
		chatToInsert := payload.MapToEntity()
		chatToInsert.Slug = generatedSlug
		expectedChat := &entity.GroupChat{Chat: newTestChat()}
		suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(expectedChat, nil)

		chat, err := suite.chatsUseCase.CreateGroupChat(ctx, payload)
		assert.NoError(t, err)
		assert.Equal(t, expectedChat, chat)
	})

	// test all possible errors are handled
	var ctx context.Context
	var payload *dto.CreateGroupChat
	testCases := []testCase{
		{
			name:     "check exists error",
			expected: (*entity.GroupChat)(nil),
			mock: func() {
				suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, payload.MembersIds).Return(false, fakeErr)
			},
			err: fakeErr,
		},
		{
			name:     "save error",
			expected: (*entity.GroupChat)(nil),
			mock: func() {
				chatToInsert := payload.MapToEntity()
				checkExistsCall := suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, payload.MembersIds).Return(true, nil)
				suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(nil, fakeErr).After(checkExistsCall)
			},
			err: fakeErr,
		},
		{
			name:     "slug generation error",
			expected: (*entity.GroupChat)(nil),
			mock: func() {
				payload.Slug = ""
				suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, payload.MembersIds).Return(true, nil)
				suite.mockSlugGenerator.EXPECT().GenerateRandomSlug().Return("", fakeErr)
			},
			err: fakeErr,
		},
		{
			name:     "already exists error",
			expected: (*entity.GroupChat)(nil),
			mock: func() {
				chatToInsert := payload.MapToEntity()
				checkExistsCall := suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, payload.MembersIds).Return(true, nil)
				suite.mockChatsRepo.EXPECT().Save(ctx, chatToInsert).Return(nil, storage.ErrAlreadyExists).After(checkExistsCall)
			},
			err: chats.ErrChatAlreadyExists,
		},
		{
			name:     "member not found error",
			expected: (*entity.GroupChat)(nil),
			mock: func() {
				suite.mockUsersRepo.EXPECT().CheckExistsByIds(ctx, payload.MembersIds).Return(false, nil)
			},
			err: chats.ErrMemberNotFound,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ctx = context.Background()
			payload = createGroupChatPayload()
			tc.mock()
			chat, err := suite.chatsUseCase.CreateGroupChat(ctx, payload)
			assert.ErrorIs(t, err, tc.err)
			assert.Equal(t, tc.expected, chat)
		})
	}
}

func TestUpdateLastMsg(t *testing.T) {
	suite := NewUseCaseTestSuite(t)
	ctx := context.Background()
	var expectedMsg *entity.Message
	testCases := []testCase{
		{
			name: "success",
			mock: func() {
				suite.mockChatsRepo.EXPECT().UpdateLastMsgInfo(ctx, expectedMsg.ChatId, expectedMsg.Text, expectedMsg.CreatedAt)
			},
		},
		{
			name: "update error (unhandled)",
			mock: func() {
				suite.mockChatsRepo.EXPECT().UpdateLastMsgInfo(ctx, expectedMsg.ChatId, expectedMsg.Text, expectedMsg.CreatedAt).Return(fakeErr)
			},
			err: fakeErr,
		},
		{
			name: "update error (not found)",
			mock: func() {
				suite.mockChatsRepo.EXPECT().UpdateLastMsgInfo(ctx, expectedMsg.ChatId, expectedMsg.Text, expectedMsg.CreatedAt).Return(storage.ErrNotFound)
			},
			err: chats.ErrChatNotFound,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			expectedMsg = newTestMsg()
			tc.mock()

			err := suite.chatsUseCase.UpdateLastMsg(ctx, expectedMsg)
			assert.ErrorIs(t, err, tc.err)
		})
	}
}
