package chats_test

import (
	"context"
	"errors"
	"testing"

	"github.com/AlexeyTarasov77/messanger.chats/internal/dto"
	"github.com/AlexeyTarasov77/messanger.chats/internal/entity"
	"github.com/AlexeyTarasov77/messanger.chats/internal/gateways/storage"
	"github.com/AlexeyTarasov77/messanger.chats/internal/usecase"
	"github.com/AlexeyTarasov77/messanger.chats/internal/usecase/chats"
	"github.com/AlexeyTarasov77/messanger.chats/internal/usecase/tests"
	"github.com/brianvoe/gofakeit"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
)

var fakeErr = errors.New("fake error")

func createGroupChatPayload() *dto.CreateGroupChat {
	return &dto.CreateGroupChat{
		CurrentUserId: gofakeit.Number(1, 999999),
		Name:          gofakeit.Name(),
		Slug:          gofakeit.Name(),
		ImageURL:      gofakeit.URL(),
		Description:   gofakeit.Sentence(5),
		MembersIds:    []int{gofakeit.Number(1, 999999), gofakeit.Number(1, 999999)},
		IsPublic:      gofakeit.Bool(),
	}

}

func TestCreateGroupChat(t *testing.T) {
	suite := usecase_test.NewUseCaseTestSuite(t)
	t.Run("success with members", func(t *testing.T) {
		ctx := context.Background()
		tx := usecase_test.SetTxExpectations(ctx, suite, true)
		txCtx := usecase.SetTransaction(ctx, tx)
		payload := createGroupChatPayload()
		chatToInsert := payload.MapToEntity()
		expectedChat := &entity.GroupChat{Chat: usecase_test.NewTestChat()}
		suite.MockChatsRepo.EXPECT().Save(txCtx, chatToInsert).Return(expectedChat, nil)
		checkExistsCall := suite.MockUsersRepo.EXPECT().CheckExistsByIds(txCtx, payload.MembersIds).Return(true, nil)
		suite.MockChatsRepo.EXPECT().AddMembers(txCtx, expectedChat.GetID(), payload.MembersIds).Return(nil).After(checkExistsCall)

		chat, err := suite.ChatsUseCase.CreateGroupChat(ctx, payload)
		assert.NoError(t, err)
		assert.Equal(t, expectedChat, chat)
	})
	t.Run("success without members", func(t *testing.T) {
		ctx := context.Background()
		tx := usecase_test.SetTxExpectations(ctx, suite, true)
		txCtx := usecase.SetTransaction(ctx, tx)
		payload := createGroupChatPayload()
		payload.MembersIds = nil
		chatToInsert := payload.MapToEntity()
		expectedChat := &entity.GroupChat{Chat: usecase_test.NewTestChat()}
		suite.MockChatsRepo.EXPECT().Save(txCtx, chatToInsert).Return(expectedChat, nil)

		chat, err := suite.ChatsUseCase.CreateGroupChat(ctx, payload)
		assert.NoError(t, err)
		assert.Equal(t, expectedChat, chat)
	})
	t.Run("success with autogenerated slug", func(t *testing.T) {
		ctx := context.Background()
		payload := createGroupChatPayload()
		payload.MembersIds = nil
		payload.Slug = ""
		expectedChat := &entity.GroupChat{Chat: usecase_test.NewTestChat()}
		mock := func(withLinkCollision bool) {
			tx := usecase_test.SetTxExpectations(ctx, suite, true)
			txCtx := usecase.SetTransaction(ctx, tx)
			fakeSlug := gofakeit.UUID()
			suite.MockSlugGenerator.EXPECT().GenerateRandomSlug().Return(fakeSlug, nil)
			chatToInsert := payload.MapToEntity()
			chatToInsert.PrimaryLinkUrl = fakeSlug
			var linkExistsCall *gomock.Call
			if withLinkCollision {
				suite.MockLinksRepo.EXPECT().CheckExistsByUrl(ctx, fakeSlug).Return(true, nil)
				suite.MockSlugGenerator.EXPECT().GenerateRandomSlug().Return(fakeSlug, nil)
				linkExistsCall = suite.MockLinksRepo.EXPECT().CheckExistsByUrl(ctx, fakeSlug).Return(false, nil)
			} else {
				linkExistsCall = suite.MockLinksRepo.EXPECT().CheckExistsByUrl(ctx, fakeSlug).Return(false, nil)
			}
			suite.MockChatsRepo.EXPECT().Save(txCtx, chatToInsert).Return(expectedChat, nil).After(linkExistsCall)
		}
		assertSuccess := func() {
			chat, err := suite.ChatsUseCase.CreateGroupChat(ctx, payload)
			assert.NoError(t, err)
			assert.Equal(t, expectedChat, chat)
		}
		t.Run("no collision", func(t *testing.T) {
			mock(false)
			assertSuccess()
		})
		t.Run("handled collision", func(t *testing.T) {
			mock(true)
			assertSuccess()
		})
	})

	// test all possible errors are handled
	var ctx context.Context
	var payload *dto.CreateGroupChat
	testCases := []usecase_test.TestCase{
		{
			Name:     "check users exists error",
			Expected: (*entity.GroupChat)(nil),
			Mock: func() {
				tx := usecase_test.SetTxExpectations(ctx, suite, false)
				txCtx := usecase.SetTransaction(ctx, tx)
				expectedChat := &entity.GroupChat{Chat: usecase_test.NewTestChat()}
				suite.MockChatsRepo.EXPECT().Save(txCtx, payload.MapToEntity()).Return(expectedChat, nil)
				suite.MockUsersRepo.EXPECT().CheckExistsByIds(txCtx, payload.MembersIds).Return(false, fakeErr)
			},
			Err: fakeErr,
		},
		{
			Name:     "check link exists error",
			Expected: (*entity.GroupChat)(nil),
			Mock: func() {
				payload.Slug = ""
				fakeSlug := gofakeit.UUID()
				suite.MockSlugGenerator.EXPECT().GenerateRandomSlug().Return(fakeSlug, nil)
				suite.MockLinksRepo.EXPECT().CheckExistsByUrl(ctx, fakeSlug).Return(false, fakeErr)
			},
			Err: fakeErr,
		},
		{
			Name:     "save error",
			Expected: (*entity.GroupChat)(nil),
			Mock: func() {
				tx := usecase_test.SetTxExpectations(ctx, suite, false)
				txCtx := usecase.SetTransaction(ctx, tx)
				chatToInsert := payload.MapToEntity()
				suite.MockChatsRepo.EXPECT().Save(txCtx, chatToInsert).Return(nil, fakeErr)
			},
			Err: fakeErr,
		},
		{
			Name:     "slug generation error",
			Expected: (*entity.GroupChat)(nil),
			Mock: func() {
				payload.Slug = ""
				suite.MockSlugGenerator.EXPECT().GenerateRandomSlug().Return("", fakeErr)
			},
			Err: fakeErr,
		},
		{
			Name:     "chat already exists error",
			Expected: (*entity.GroupChat)(nil),
			Mock: func() {
				tx := usecase_test.SetTxExpectations(ctx, suite, false)
				txCtx := usecase.SetTransaction(ctx, tx)
				chatToInsert := payload.MapToEntity()
				suite.MockChatsRepo.EXPECT().Save(txCtx, chatToInsert).Return(nil, storage.ErrAlreadyExists)
			},
			Err: chats.ErrChatAlreadyExists,
		},
		{
			Name:     "member not found error",
			Expected: (*entity.GroupChat)(nil),
			Mock: func() {
				tx := usecase_test.SetTxExpectations(ctx, suite, false)
				txCtx := usecase.SetTransaction(ctx, tx)
				expectedChat := &entity.GroupChat{Chat: usecase_test.NewTestChat()}
				suite.MockChatsRepo.EXPECT().Save(txCtx, payload.MapToEntity()).Return(expectedChat, nil)
				suite.MockUsersRepo.EXPECT().CheckExistsByIds(txCtx, payload.MembersIds).Return(false, nil)
			},
			Err: chats.ErrMemberNotFound,
		},
		{
			Name:     "member already in chat error",
			Expected: (*entity.GroupChat)(nil),
			Mock: func() {
				tx := usecase_test.SetTxExpectations(ctx, suite, false)
				txCtx := usecase.SetTransaction(ctx, tx)
				expectedChat := &entity.GroupChat{Chat: usecase_test.NewTestChat()}
				suite.MockChatsRepo.EXPECT().Save(txCtx, payload.MapToEntity()).Return(expectedChat, nil)
				suite.MockUsersRepo.EXPECT().CheckExistsByIds(txCtx, payload.MembersIds).Return(true, nil)
				suite.MockChatsRepo.EXPECT().AddMembers(txCtx, expectedChat.GetID(), payload.MembersIds).Return(storage.ErrAlreadyExists)
			},
			Err: chats.ErrMemberAlreadyInChat,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.Name, func(t *testing.T) {
			ctx = context.Background()
			payload = createGroupChatPayload()
			tc.Mock()
			chat, err := suite.ChatsUseCase.CreateGroupChat(ctx, payload)
			assert.ErrorIs(t, err, tc.Err)
			assert.Equal(t, tc.Expected, chat)
		})
	}
}
